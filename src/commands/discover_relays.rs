use crate::config::get_default_relays;
use crate::relay::{discover_relays_from_nostr_watch, test_relays_concurrent, RelayTestResult};
use chrono::Utc;
use indicatif::{ProgressBar, ProgressStyle};
use std::collections::HashSet;
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;
use std::time::Duration;

pub async fn execute(
    output: PathBuf,
    configured_only: bool,
    timeout_secs: u64,
    concurrent: usize,
    verbose: bool,
) -> anyhow::Result<()> {
    println!("Discovering relays...");

    let mut all_relays: HashSet<String> = HashSet::new();

    // 1. Fetch from nostr.watch (unless configured_only)
    if !configured_only {
        match discover_relays_from_nostr_watch().await {
            Ok(relays) => {
                println!("  Fetched {} relays from nostr.watch", relays.len());
                all_relays.extend(relays);
            }
            Err(e) => {
                eprintln!("  Warning: Failed to fetch from nostr.watch: {}", e);
            }
        }
    }

    // 2. Add configured relays
    let configured = get_default_relays();
    println!("  Added {} configured relays", configured.len());
    all_relays.extend(configured);

    if all_relays.is_empty() {
        return Err(anyhow::anyhow!("No relays to test"));
    }

    let relay_list: Vec<String> = all_relays.into_iter().collect();
    println!("  Testing {} unique relays...\n", relay_list.len());

    // 3. Set up progress bar
    let pb = ProgressBar::new(relay_list.len() as u64);
    pb.set_style(
        ProgressStyle::default_bar()
            .template("{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos}/{len} relays")?
            .progress_chars("#>-"),
    );

    let pb_clone = pb.clone();
    let progress_callback = Box::new(move |done: usize, _total: usize| {
        pb_clone.set_position(done as u64);
    });

    // 4. Test relays concurrently
    let timeout = Duration::from_secs(timeout_secs);
    let results = test_relays_concurrent(relay_list, concurrent, timeout, Some(progress_callback)).await;

    pb.finish_and_clear();

    // 5. Separate working and failed relays
    let mut working: Vec<&RelayTestResult> = results.iter().filter(|r| r.is_working()).collect();
    let failed: Vec<&RelayTestResult> = results.iter().filter(|r| !r.is_working()).collect();

    // Sort working relays by latency
    working.sort_by_key(|r| r.latency_ms.unwrap_or(u64::MAX));

    // 6. Print results
    println!("Results:");
    for result in &working {
        let latency = result.latency_ms.map(|ms| format!("{}ms", ms)).unwrap_or_else(|| "?".to_string());
        println!("  \x1b[32m✓\x1b[0m {:<45} - {}", result.url, latency);
    }

    if verbose {
        for result in &failed {
            let error = result.error.as_deref().unwrap_or("unknown error");
            println!("  \x1b[31m✗\x1b[0m {:<45} - {}", result.url, error);
        }
    } else if !failed.is_empty() {
        println!("  ... and {} failed relays (use --verbose to see)", failed.len());
    }

    println!(
        "\nSummary: {}/{} relays working",
        working.len(),
        results.len()
    );

    // 7. Save working relays to file
    if working.is_empty() {
        println!("\nNo working relays found. Output file not created.");
        return Ok(());
    }

    let mut file = File::create(&output)?;
    writeln!(file, "# Generated by nostrsave discover-relays")?;
    writeln!(file, "# Date: {}", Utc::now().format("%Y-%m-%dT%H:%M:%SZ"))?;
    writeln!(file, "# Working: {}/{} tested", working.len(), results.len())?;
    writeln!(file)?;

    for result in &working {
        writeln!(file, "{}", result.url)?;
    }

    file.flush()?;
    file.sync_all()?;

    println!("Saved to: {}", output.display());

    Ok(())
}
